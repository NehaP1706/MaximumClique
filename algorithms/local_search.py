"""
advanced_local_search.py
------------------------
Implements an advanced deterministic local search algorithm
for the Maximum Clique Problem.

This method explores multiple neighborhoods (add, swap, and remove+expand),
using pruning, degree-based ordering, and incremental neighbor intersection
to efficiently approach a near-optimal clique deterministically.

Time Complexity: 
- Dense graphs: O(n^3)
- Sparse Graphs: O(n * d * k)
- Typical: O(t * d * k)
- Worst Case: O(t * (n * log(n) + n * k^2))

Space Complexity: O(n + m)

where:
n = |V| : number of vertices
m = |E| : number of edges
k = |C| : size of current Clique (k << n)
d = average degree of all vertex in the graph

Author: Neha Prabhu
Date: November 2025
"""

import time

def init_greedy(G):
    """
    Greedy initialization for maximum clique.
    Matches local_search expectations:
    - G: adjacency dictionary {node: set(neighbors)}
    Returns:
        clique (set): nodes forming the greedy clique
        runtime (float): time taken in seconds
    """

    start_time = time.time()

    # Sort nodes by degree descending
    nodes_sorted = sorted(G.keys(), key=lambda x: len(G[x]), reverse=True)

    best_clique = set()

    # Greedy trial: start a clique from each node
    for node in nodes_sorted:
        clique = {node}

        for other in nodes_sorted:
            if other == node:
                continue
            # Check if 'other' connects to all current clique members
            if all(other in G[member] for member in clique):
                clique.add(other)

        if len(clique) > len(best_clique):
            best_clique = clique

    runtime = time.time() - start_time
    return best_clique, runtime

def local_search(G):
    """
    Advanced deterministic local search for the maximum clique problem.

    Parameters
    ----------
    G : dict
        Graph represented as an adjacency dictionary {node: {neighbors}}.
        Each node maps to a set of vertices it is connected to.
    start_clique : list or set
        Initial clique (seed vertices).
        Often used to build upon the answer generated by a greedy algorithm

    Returns
    -------
    clique : set
        Set of vertices forming the locally optimal clique.
    runtime : float
        Time taken to execute the algorithm in seconds.

    Notes
    -----
    - Uses adjacency set representation for O(1) edge checks.
    - Employs candidate pruning and degree-based ordering.
    - Incrementally maintains candidate lists for efficiency.
    - Deterministic behavior (no random elements).
    - len(G[v]) : degree of vertex v, descending order to consider max-degree first
    """

    start_time = time.time()
    clique, times = init_greedy(G)
    improved = True

    # Prunes all vertices that canâ€™t connect to every member of the current clique.
    candidates = set(G.keys()) - clique
    for u in list(candidates):
        if not all(u in G[v] for v in clique):
            candidates.remove(u)

    n = G.keys().__len__()
    add = 0
    swap = 0
    remove_expand = 0

    # Main improvement loop
    while improved:
        improved = False

        # ADD: add a vertex v with degree ordering and candidate pruning
        add_candidates = sorted(candidates, key=lambda v: len(G[v]), reverse=True)
        add += 1

        if (add == n):
            break

        for v in add_candidates:
            
            # Check if vertex v is connected to all members of the current clique
            if all(v in G[u] for u in clique):
                clique.add(v)

                # Take the set intersection of the current candidates and the neighbours of v not in clique
                candidates &= G[v] - clique

                improved = True
                break
        
        if improved:
            continue

        # SWAP: try replacing low-degree vertex
        sorted_clique = sorted(clique, key=lambda u: len(G[u]))
        swap += 1

        if (swap == n):
            break

        for u in sorted_clique:

            # Potential swap-ins: vertices connected to all except 'u'
            swap_candidates = [
                v for v in G                                                            # Search over all vertices in the graph that is not in the clique
                if v not in clique and all(x == u or v in G[x] for x in clique)         # x (in clique) is the vertex we plan to remove or v is connected to x
            ]
            
            for v in sorted(swap_candidates, key=lambda x: len(G[x]), reverse=True):    # Consider vertices in decreasing order of degree
                new_clique = (clique - {u}) | {v}                                       # Swap out u and use v

                if all((a in G[b]) for a in new_clique for b in new_clique if a != b):  # Check if the resultant is a clique
                    clique = new_clique

                    candidates = set.intersection(*(G[x] for x in clique)) - clique     # Keep only vertices that are adjacent to all members of the new clique

                    improved = True
                    break
            
            if improved:
                break
        
        if improved:
            continue

        # REMOVE + EXPAND: Remove a vertex and try for better
        sorted_clique2 = sorted(clique, key=lambda x: len(G[x]))
        remove_expand += 1

        if (remove_expand == n):
            break   

        for u in sorted_clique2:
            reduced = clique - {u}                                                      # Remove vertex u from the clique

            # Potential expansions: Candidates that can connect to all reduced members
            expand_candidates = [
                v for v in candidates 
                if all(v in G[x] for x in reduced)
            ]
            
            for v in sorted(expand_candidates, key=lambda x: len(G[x]), reverse=True):  # Consider vertices in decreasing order of degree
                new_clique = reduced | {v}                                              # Add the selected vertex
                
                if len(new_clique) > len(clique):                                       
                    clique = new_clique

                    candidates = set.intersection(*(G[x] for x in clique)) - clique     # Keep only vertices that are adjacent to all members of the new clique

                    improved = True
                    break
            
            if improved:
                break
        
        if improved:
            continue

    runtime = time.time() - start_time
    return clique, runtime


if __name__ == "__main__":
    # Example test (runs only when you execute this file directly)
    # Define a simple undirected graph as adjacency sets
    G = {
        1: {2, 3},
        2: {1, 3},
        3: {1, 2, 4},
        4: {3, 5, 6},
        5: {4, 6},
        6: {4, 5}
    }

    best, runtime = local_search(G)

    print(f"Advanced Local Search Clique: {best}")
    print(f"Size: {len(best)}, Time: {runtime:.6f} seconds")
